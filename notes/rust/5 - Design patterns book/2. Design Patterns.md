-> General reusable solutions to commonly occurring problems within a given context.
-> Careful not to add unnecessary complexity where programs do not need the deisng pattern

# Behavioural Patterns
-> Identify common communication patterns among objects
## Command pattern
-> Separate actions into their own objects and pass them as parameters

-> Approach: Using trait objects
	-> Define a trait which encapsulates the commands and all command structs will implement that trait

-> Aprroach: Using function pointers
	-> Each individual command as a different function and store function pointers to invoke them later at different times. Implements `Fn, FnMut, FnOnce` so these could also be closures

-> Approach: Using `Fn` trait objects
	-> Instead of defining common command trait we could store each command implementing the `Fn` trait separately in vectors

## Interpreter pattern
-> Basically a dsl parser

## Newtype pattern
-> Wrap a type in a newtype through a struct so it behaves differently in some scenarios when you pass in the newtype as type argument
-> To not be confused with type aliases `type`

## RAII /w guards
-> Resource initialisation is done in the constructor of an object and finalisation in the destructor
-> The pattern is extended in Rust by using a RAII object as guard of some resource and relying on the type system to ensure that access is always mediated by the guard object
-> A good example from `std` is the `Mutex` lock

## Strategy pattern
-> Basically separation of concerns, defining an abstract skeleton of the solution to a particular problem in one part of the code, which will be made public for users and in another part of the code having the implementations, which the users do not have to bother with


# Creational Patterns
-> Object creation mechanisms

## Builder pattern
-> Construct an object with calls to a builder helpers

## Fold


# Structural patterns
-> Identify simple ways to realize relationships among entities

## Struct decomposition
-> Have a struct formed of other structs (maybe newtypes) so that when you use part of the struct you will not get borrow checker errors

