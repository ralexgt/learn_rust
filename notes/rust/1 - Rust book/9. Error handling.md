[[learning]]  [[programming]]
-> Rust requires you to acknowledge the possibility of an error and treat it accordingly at compile time
-> Recoverable vs unrecoverable errors
	-> for recoverable errors, such as file not found, we most likely just want to report the problem to the user and retry
	-> Unrecoverable errors are symptoms of bugs, such as trying to access a location beyond the end of an array, and so we want to immediately stop the program
-> While other programming languages don't make the distiction between them and handle both types with exceptions or some other concept, Rust makes this difference

-> The type `Result<T, E>` is for recoverable errors
-> `panic!` macro stops the execution when the program encounters an unrecoverable error

# Unrecoverable errors with `panic!`
-> 2 ways to cause a panic in a Rust program. 
	-> Take an action that causes the code to panic (accessing an array past the end)
	-> Explicitly call the `panic!` macro

-> By default, those panics print a failure message, unwind, clean up the stack and quit

-> While the default response to a panic in Rust is unwinding the stack, walking back up the stack and cleaning up the data, this is a lot of word.
Thus, rust allows you to choose the alternative of immediately aborting, which ends the program without cleaning up
-> If you need your resulting binary to be as small as possible you can opt in to your program aborting in `Cargo.toml` by adding `[profile.release \n panic = 'abort'`

# Recoverable Errors with `Result`
-> Most of the time, if a function fails you want to interpret and respond to the error. Ex. if openning a file fails because the file doesn't exists, you might want to create the file instead of terminating the process

-> `Result<T, E>` is an Enum with 2 variants
	-> `Ok(T)`,
	-> Err(E),`
-> If a function could fail, it's normal to return a `Result` value
-> Usually use `match` expressions to branch through these. It is often that you have nested `matches`. To avoid so many `match` you can use `closures`, like `.unwrap_or_else`
	-> or encapsulate your logic in `another_function()`, then call `another_function()?`
	-> Use guards in the match expression. Ex. `Err(error) if error.kind() == SomeError => ...`

-> **Propagating errors**
	-> You can define your own functions to return `Result`
	-> You can explicetely in your `match` expressions use `Err(error) => return Err(error)`
	-> This pattern is used so often that Rust added the `?` operator
-> `?` shortcut
	-> If the function call returns an error, `?` returns mostly like the `match branching`, so `file::open()?` will return `file` from `Ok(file)` if it succedes or the `Err(error)` if it doesnt
	-> `?` can only be used in functions whose return type match the Error type returned by `?`
	-> `?` can also be used for functions that return `Option<T>`

![[Screenshot from 2026-01-02 16-05-26.png]]---- Example of creating a custom type for error handling at initialization


***Panic*** means that the program got into a bad state and tells the process to stop instead of trying to proceed with invalid or incorrect values
***Result*** enum uses Rust's type system to indicate that operations might fail in a way that your code can recover from. Use it to tell code that calls your code that it needs to handle potential success or failures as well