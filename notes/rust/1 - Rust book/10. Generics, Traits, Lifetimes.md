[[learning]]  [[programming]]
-> Effectively handle the duplication of concepts

# Generics
-> Abstract stand-ins for concrete types or other properties
-> Functions can take parameters of some generic type instead of a concrete type
-> Can be used in structs and enums definitions

-> By convention, we use `T` to parametirize types. Even if not `T`, USUALLY it is only one letter
-> To use a type parameter in a function, similarly to arguments, you need to declare the type parameter name before using it
-> To declare the type parameter, place it in `<>` before the `()`

-> Adding generics does not affect performance of the program at runtime. The compiler looks at compile time where the generics are used and generates code for all the types used in place of generics. (might add memory overhead? but you also would do that duplication by hand so I dont think so)

# Traits
-> Similar to `interfaces` in other languages, but with some differences
-> Defines the functionality a particular type has and can share with other types
-> Traits can be used to define shared behavior in an abstract way
-> Trait **bounds** are used to specify that a generic type can be any type that has certain behavior
-> `trait` keyword
-> `trait <Name> {functions;}` to define
-> `impl TraitName for StructName {}`
-> You can, in the `trait` definition define a default implementation for functions in `{}`

-> We can use traits in the function signature instead of concrete types
	-> `item: &impl TraitName`
-> Similarly we can define trait bounds for abstract type
	-> `<T: TraitName>`
-> You can have multiple trait bounds on a type with `+` sign
	-> `<T: Trait1Name + Trait2Name>`
-> If the code gets too hard to read from so many stuff, you can add the trait bound right after the function signature and before the `{}` of the function with the `where` clause
	-> `fn name<T>(...) where T: TraitName + TraitName2, {}`
	-> This gives as a less cluttered function signature


# Lifetimes `'a`
-> Lifetimes ensure that references are valid as long as we need them to be
-> Every reference in Rust has a lifetime, which is the scope for which that reference is valid
-> Most of the times, they are implicit and iferred
-> We are only required to annotate lifetimes when lifetimes of references could be related in a few different ways
-> Lifetime **annotation** don't actually change how much a reference lives, it just hints the compiler to the relationship between the lifetimes of a few references
-> `&'a i32` -> lifetime annotation `'a`

-> If we have references in a struct, we need to annotate each of them to tell the compiler that the reference will live for  at least as long as the struct lives

-> A special lifetime is `'static`, denoting that the affected reference can live for the entire duration of the program
-> For ex., string literals are all `'static`, being written in the compiled binary




![[Screenshot from 2026-01-04 20-21-12.png]]
---- all used together