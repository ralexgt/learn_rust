[[learning]]  [[tooling]]
-> So far the code was in one module, one file
-> As the proeject grows, you should separate the functionalities in multiple modules, with multiple files
-> A package can contain multiple binary crates and optionally ONE library crate
-> As a project grows, you can extract certain parts of it other crates and put them as external dependencies

-> Encapsulating implementation => lets you use code at a higher level
	-> Once you create an operation, other parts of code can call it through a public interface, without the need of seeing the implementation
-> As you develop code, you can choose which parts are public and which are private and won't be changed by other parts of the code

# Modulirazing tools
-> **Package** => Cargo tool that lets you run, test, publish and share crates
-> **Crate** => A tree of modules that produce a library or an executable
-> **Modules and use** => Let you control the organization, scope and privacy of paths
-> **Path** => A way of naming an item such as a struct, function or module


# Packages and crates
-> A **crate** is the smalles amount of code that Rust compiler considers at a time
-> Crates can contain modules and the modules may be defined in multiple files that get compiles within the crate

-> Crates can be either **binary** or **library** crates
	-> binary crates can be compiled to an executable, such as a command line program or a server. Each binary crate has to contain a main function that defines what happens at the execution
	-> library crates don't compile to an executable. They define functionality intended to be shared between multiple projects, ex. `rand` crate. Library crates don't have a main function.
-> Most of the time when Rust people say `crate` they mean `library crate` and the terms are used interchangebly. Such as a `crate` is what in general programming terms is a `library`.

-> Each crate needs a root. The crate root is a Rust file that the compiler uses as the starting point and uses to make the **root module** for the crate

-> A **package** is a bundle of crates that provides a set of functionality
-> A package contains a Cargo.toml file that describes how to build those crates
-> For example, Cargo is a package that contains the binary crate for the command line tool `cargo`. Cargo also contains a library crate on which the binary crate depends
-> A package can contain as many binary crates and at most one library crate. Also, a package must contain at least one crate, whether it is binary or library

-> `cargo new project-name` creates the package with the name `project-name`
	-> It also creates the following structure: `Cargo.toml` and `src/main.rs`
	-> Rust follows the convention that `src/main.rs` is the crate root of a binary crate with the same name as the package
	-> If the package contains a `src/lib.rs` it contains a library crate with the same name as the packge and `src/lib.rs` is its crate root
-> Cargo passes those 2 files `src/main.rs` and `src/lib.rs` to rustc to build the library and the binary
-> A package can have multiple binary crates by placing files in `src/bin` directory, each file being a binary crate

# Modules and paths
-> `use` brings a path into scope
-> `pub` makes an item public
-> `mod` declare a new module

-> When compiling a crate, the compiler first looks at the crate root. Generally `src/lib.rs` or `src/main.rs` for code to compile
-> In the crate root you can declare new modules, let's say `mod garden;`
	-> Then the compile will look for the module in the following places: first inline, in curly brackets that replace the `;` with the code block specific to the module. Secondly in the file src/garden.rs (same name as the module from `mod garden;`), thirdly in the file `src/garden/mod.rs`
-> In any other module than root you can declare **submodules**. So for example in `src/garden.rs` you could declare `mod vegetables;` and again, use the 3 locations the compiler looks for the submodule: curly brackets, `src/garden/vegetables.rs` or `src/garden/vegetables/mod.rs`

-> After declaring the module, you can refer to code in that module anywhere in the crate where the path is public/accessible.
	-> For example, the `Asparagus` type in `vegetables` module would be found the the following path: `crate::garden::vegetables::Asparagus`

-> Code within a module is **private** to the module parents by default. Ex: `vegetables` can see the code in `garden`, but `garden` can't see the code in `vegetables`.
-> To make a module **public** use `pub mod` instead of `mod`
-> After making a public module, you also need to add `pub` before the declaration of items, so they are explicitely public.

-> Within a scope, the `use` keyword creates shortcuts to items to reduce repetition of long paths.
-> So if you can refer to `crate::garden::vegetables::Asparagus`, you can create a shortcut with `use crate::garden::vegetables::Asparagus;` and from there only write `Asparagus`
-> You can `use <path> as <alias>` to create an alias 

-> `super` refers to the parent mod and `self` to the current mod

-> `use` only creates the shortcut in the scope in which the statement occurs. So it won't work in nested modules for example
	-> You can make the shortcut public to other scopes with `pub use <path>`

-> \* is the Glob Operator and it imports everything at that path

-> When you have both `main.rs` and `lib.rs`, main depends on lib. So in `main.rs` you can `use <crate_name>::rest::of::path`, but in `lib.rs` you can not import from the binary


# Example of a module tree with a binary crate `main.rs` and lib crate `lib.rs`
-- main.rs (this has mod m1)
-- lib.rs (this has mod lib1)
\-- m1.rs (this has mod m2)
\-- m1/m2.rs (this is the submodule m2)
\-- lib1.rs (this is the module defined in the library crate)
