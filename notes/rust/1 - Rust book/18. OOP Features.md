[[learning]]  [[programming]]
-> How to structure idiomatic Rust code
-> Implementing object-oriented design pattern in Rust and see the trade-off of doing so versus implementing a solution using Rust's strengths

# Characteristics of OO languages
-> Objects, encapsulation, inheritance, polymorphism
# Trait Objects to abstract over shared behavior
-> One example of a limitation is that vectors can only store data of the same type. We created a workaround before defining an `enum` that had variants to hold integers, floats and text, meaning we could store different types in the same vector. This is **good** when we know all the types at compile time
-> However, sometimes users of our library should be able to extend the set of types that are valid in particular situations. In a language with *inheritance*, we would define a class that has a method to be implemented. The other classes defined by programmers using our library will inherit that method from out parrent class and thus inherit and implement the specific method. Rust doesn't have inheritance, so we will use something else
-> ***A Trait for Common Behavior*** - we will define a trait that will have the method we want all structs to implement. Then, we can define a vector that takes that **trait object**
-> To create a trait object we use some sort of pointer, such as a reference or a `Box<T>` smart pointer, then the `dyn` keyword, then specifying the relevant trait (we wouldnt know the size of the structs that implement that trait, so we need to allocate it dynamically on the heap)
-> Rust will ensure at compile time that anywhere we use a trait object, the value used implements the trait object's trait. So we don't need to know all the types when compiling the library. The compiler will check in the users code to see that they implement the specific behavior needed

-> A generic can be replaced with only one specific type at a time With object traits, they can be replaced by any type that implements that trait

-> Implementing the Trait Object with dyn involves dynamic dispatch. Meaning that the compiler doesn't know at compile time all the times to statically add the code for that types. It will have some references to help at runtime lookup for the types. This lookup involes runtime costs. Also, those lookups mean the compile will not be able to inline specific functions, which will also lead to optimizations being missed. However, the extra flexibility in the code is a trade-off to ***consider***

# OOP Design Pattern
-> The state pattern basically says that an object has a field to hold its state
