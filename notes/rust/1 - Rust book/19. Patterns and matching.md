[[learning]]  [[programming]]
-> Patterns are special syntax in Rust for matching against the structure of types, both complex and simple
-> Used in conjunciton with `match` expressions and other constructs give you more control over a program's control flow
-> A pattern consists of some combination of the following:
	-> Literals
	->  Destructured arrays, enums, structs, tuples
	-> Variables
	-> Wildcards
	-> Placeholders
-> Patterns describe the shape of data

# Where patterns can be used
-> `match` **Arms**
	-> `match` expressions need to be exhaustive. All the posibilities for the value in the expression must be accounter for. One way to ensure that is to have a catch-all pattern like a variable name matching any value and thus will never fail
	-> `_` will match anything, but never bind to a variable, so it is often used as the last match arm

-> `let` **Statements**
	-> Like destructuring a tuple
-> Conditional `if let` expressions
	-> You can optionally use `else` to run code if the pattern doesn't match or `else if` or `else if let`
-> `while let` conditional loops
	-> Similar to `if let`, they allow a `while` loop to run for as long as a pattern continue to match
-> `for` loops for deconstructing tuples
-> In `fn` parameters

# Refutability
-> Whether a Pattern might fail to match
-> Patterns can be refutable and irrefutable
-> Patterns that will match for any possible value passed are irrefutable

-> Function parameters, `let` statements and `for` loops can only accept irrefutable patterns
-> `if let` and `while let` expression and the `let .... else` statements accept refutable and irrefutable patterns, but the compiler warns against irrefutable patterns

-> Generally, you do not worry about a pattern being refutable or irrefutable, but you need to be familiar with the term so that you can respond when you see it in an error message
-> In case of errors, you will need to change either the pattern or the construct you are using the pattern with

# Pattern matching syntax
-> You can `match` directly on literals (ex. 1, 2, 3, \_)
-> Use named variables in the `match` arms
-> You can use `|` as an `or`
-> You can use `..` as a range
-> Deconstucting structs, tuples: `let Point { x: a, y: b } = p;`
-> Matching enums
-> Nested structs and enums
-> You can add match arms with match guards, like `Some(x) if x % 2 == 0`