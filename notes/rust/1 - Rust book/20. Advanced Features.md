[[learning]]  [[programming]]

# Unsafe Rust
-> *Unsafe* Rust is a part of the language that doesn't enforce the memory safety guarantees we have become acustomed to in Rust
-> It exists because static analysis is conservative. It prefers to reject correct code if it doesn't have enough information, rather than have the possibility of accepting broken code
-> Unsafe Rust is used to tell the compiler "Trust me bro, I know what I'm doing"
-> Another reason is that hardware is inherently unsafe. If you couldn't write unsafe code, certain tasks would not be possible

-> To switch to unsafe Rust, use the `unsafe` keyword and start a new block that holds the unsafe code
-> In unsafe code blocks you can:
	-> Dereference a raw pointer
	-> Call an unsafe function or method
	-> Access or modify a mutable static variable
	-> Implement an unsafe trait
	-> Access fields of `union`s
-> It's important to know that `unsafe` doesn't automatically disable all the compiler's checks. There will still be the borrow checker for safety checks
-> Also, `unsafe` does not mean the code is necessarily dangerous or has memory safety problems. It only means that the programmer has to ensure that the code will access memory in a valid way

-> Keep unsafe code blocks small. This will be of great help when debugging memory bugs

-> It is best practice to wrap unsafe code into safe APIs so you or others do not take unsafe actions without knowing

-> In unsafe Rust, we have new types called **raw pointers** that are similar to references
-> As with references, raw pointers can be immutable `*const T` or mutable `*mut T`. Here `*` is not dereferencing, it is part of the type name
-> Differences between references, smart pointers vs. raw pointers:
	-> They are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location
	-> Aren't guaranteed to point to valid memory
	-> Are allowed to be null
	-> Don't implement any automatic cleanup
-> By opting out of having Rust enforce these guarantees you can in exchange get greater performance or ability to interface with another language or hardware, where Rust's guarantees don't apply
-> `&raw const` is an immutable raw pointer and `&raw mut` is mutable
-> Dereferencing the raw pointers is ***unsafe***

-> You can use `unsafe` in front of a `fn`, declaring that the function can only be used in unsafe code blocks

## Abstraction over unsafe code
-> Just because you use unsafe code in a function doesnt mean you **have** to declare the entire function unsafe. You can wrap the unsafe code in an unsafe block and have the function be nromal. You will be allowed to call the function anywhere in the code

## Use of Foreign Function Interface (FFI)
-> `extern` facilitates the creation an duse of a FFI which is a way for a programming language to define functions and enable a different programming language to call those functions
-> `unsafe extern "C" {}`

-> Similarly you can declare extern functions to be used in other languages
-> `#[unsafe(no_mangle)] pub extern "C" fn call_from_c() {}`

## Miri to check unsafe code
-> Miri is the official Rust tool for detecting undefined behavior
-> It is dynamic and works at runtime
-> It requires a nightly build of Rust

# Advanced traits
-> Associated types connect a type placeholder with a trait.
-> The trait method can use these placeholder types in their signatures
-> This way, the trait doesn't need to know the concrete type of the placeholder
-> Associated types become part of the trait's contract at implementation

-> Default generic parameters `<PlaceholderType=ConcreteType`
-> Useful for ex. with operator overlodaing, in which you can customize behavior of operators such as `+` in particular situations
-> You can not create your own operators or overload arbitrary operators, but you can overload the operations and corresponding traits listed in `std::ops` by implementing the traits associated with the operator
-> A trait that implements `std::ops::Add` for example will overload the `+` operator
-> You can implement operator overloading for 2 specific types. For example if you want to add `Milimiteres` to `Meters` you would implement something like `impl Add<Meters> for Milimiters` and the `add` function would take a `Meter` as the `other` parameters

-> Supertraits: when you want to write a trait that depends on another trait, you want the struct implementing the trait to also implement the trait that it depends on. The trait your trait *depends* on is called the ***supertrait***
-> `MyTrait: OtherTrait` here, OtherTrait is the supertrait and MyTrait depends on it

-> One restriciton to traits is that to implement a trait on a type, you need to have the type, the trait, or both, locally found in the crate
-> To get around this restriction is the **Newtype** pattern, term that is comming from Huskel. This pattern has no runtime overhead
-> Basically, you are creating a thin wrapper, a tuple struct around the type you want to implement traits on. This way, the Newtype is local to you crate. If you want the newtype to have every method the inner type has, you can implement the `Deref` trait on the `Wrapper`

# Advanced types
-> We have also seen the **Newtype** pattern multiple times, when we would have a wrapper `Meters` wrapping a `u32` value, or `People` wrapping a `Hashmap<i32, String>`

-> **Type aliases** are used to give an existing type another name
-> `type NewTypeName = type;` |  `type Kilometers = i32;`
-> The alias is not a separate new type. It is used just as a synonim to the respective type. So we could, in this example sum an i32 with a Kilometer
-> The main usecase is to reduce repetition

-> `!` the never type. The type that stands in the place of the return type when a function will never return

## Dinamicaly sized types (DSTs)
-> Also called *unsized* types
-> On generics, use `<T: ?Sized>` to declare the type is not statically sized
-> When a type has unknown size at compile time you need to only use the reference to it as in `&T`


# Functions and closures
-> We have seen how to pass closures to functions. You can also pass regular functions to functions
-> `fn` type is what functions coerce to. It is a **function pointer**
-> `fn` is a type, not a trait like closures `Fn`
-> Function pointers implement all three closure traits `Fn`, `FnMut`, `FnOnce`
-> You can pass a function pointer to a function that expects a closure
-> It's better to write functions that take a generic type and one of the closures, so you can call them both with functions and closures

-> You can return closures
-> But because you can not return directly traits, you will need to return a type that implements that trait, thus we use `impl Trait`


# Macros
-> Macros are like functions that end with a bang `!`, ex: `println!`
-> The term *macro* refers to a family of features in Rust:
	-> Declarative macros with `maco_rules!`
	-> Custom `#[derive]` macros hat specify code added with the `derive` attribute used on structs and enums
	-> Attribute-like macros that define custom attributes usable on any item
	-> Function-like macros that look like function calls but operate on the tokens specified as their arguments

-> Why have macros when we already have functions?
-> Fundamentally, macros are a way of writing code that writes other code, called *metaprogramming*
-> Macros can take a variable number of paraeters, for ex `println!("hello")` with one argument or `("hello {}", name)` with two arguments
-> Macros are expanded before the compiler interprets the meaning of the code so a macro can, for example, implement a trait on a givne type
-> A downside to implementing a macro instead of a function is that macro definitions are ore complex because you are writing code that writes code
-> Due to the indirection, macro definitions are generally more idfficult to read, understand and maintain
-> You must define macros or bring them into scope before you call them in a file, opposed to functions that you can call anywhere

## Declarative macros for general Metaprogramming
-> The most widely used form of macros
-> Also called *macros by example* or `macro_rules!` macros or just plain *macros*
-> At their core, they allow you to write something similar to a `match` expression
-> To define one, use `macro_rules!`
-> `#[macro_export]` indicates that this macro should be made available whenever the crate is brought into scope
-> The definition starts with `macro_rules! macro_name {}`
-> The `{}` are the macro definition body
-> The structure of the body is similar to the one of a `match`. We have arms with patterns, for ex. `( $( $:expr ),* )`, followed by the `=>` and then the block of code associated with the pattern
-> More complex macros will have more than one arm
-> Patterns here have different syntax. Macro patterns are matched against Rust code structure rather than values

-> Pattern syntax:
-> `()` are used to encapsulate the whole pattern
-> `$` declares a variable in the macro system that will contian the Rust code. It makes it clear that the variable is a mcaro variable as opposed to a regular Rust variable
-> The nested `()` captures values that match the pattern within the parantheses for use in the replacement code
-> `$x:expr` matches any Rust expression and gives the expression the name `$x`
-> `,` following the `$()` indicates that a literal comma separator characer must appear between each instance of the code
-> `*` specifies that the pattern matches zero or more of whatever precedes the `*`


## Procedural macros for generating code from attributes
-> It functions more like a function and is a type of *procedure*
-> They accept some code as an input, operate on that code and produce some code as an output
-> There are 3 types:
	-> custom `derive`
	-> attribute-like
	-> function-like
   and all work in similar fashion

-> When creating procedural macros, the definition must reside in their own crate with a special crate type (complex technical reasons that Rust hopes to eliminte in the future)
-> You will have `use proc_macro::TokenStream;`
-> `#[some_attribute]`
-> `pub fn some_name(input: TokenStream) -> TokenStream`

## Custom `derive` macros
-> Rather than making users implement the macro for each of their types, we'll provide a procedural macro so that users can annotate their type with `#[derive(HelloMacro)]` to create a default implementation
-> To mark a crate as a procedural macro crate we use `[lib]\n proc-macro = true` in `Cargo.toml`

## Attribute-like macros
-> Similar to `derive` macros, but instead you create new attributes
-> Also more flexible: `derive` only works for structs and enums
-> Attributes can be applied to other items, such as functions
-> An example that might be found in a web dev crate would be:
`#[route(GET, "/")]`
`fn index() {`
-> This would be defined by the framework as a procedular macro. The function signature of the macro would look like:
`#[proc_macro_attribute]`
`pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {`
-> The `attr` token stream would be `Get, "/"` and `item` would be `fn index() {}`


## Function-like macros
-> Define mcros that look like function clls
-> They can take an unkown number of arguments
-> Can take a `TokenStream` parameter and their definition manipulates that `TokenStream`
-> Ex. for usage: `let sql = sql!(SELECT * FROM posts WHERE id=1);`
-> The definition will be: `#[proc_macro]\n pub fn sql(input: TokenStream) -> TokenStream {`