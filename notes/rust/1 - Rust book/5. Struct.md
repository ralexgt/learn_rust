[[learning]]  [[programming]]
-> Structures let you group together and name multiple related values to make up a meaningful group of data
-> The `struct` is like an object's data attributes
-> Similar to tuples, but in structs you have to name your each individual type
-> Structs are not order specific, you can specify the data by the name

-> A `struct` can be defined and initialized
-> Definition: `struct Name {fields}`
-> Initialization: `let var = Name {fields}`
-> `fields` are key:value pairs 

-> You can access the `fields` of the structure using the dot (.) notation, like tuples

-> You can initialize the struct to a mutable value. The fields will be mutable
-> You need to make the entire initialization mutable. You can not make only specific fields

-> You can return structs and pass structs as parameters to functions

-> Struct update syntax is used to create a new struct with some fields from another struct
-> `..ini1` expands to: set all the unset fields to those of the struct initialized in ini1

# Using tuples to create new structs / types
-> Called tuple structs
-> Tuple structs only have the types of the fields, excluding the names
-> Used when you want to give a tuple a name and differentiate from other tuples, in this case giving field names would be redundant and too verbose
-> To define a tuple struct use `struct TupleName(type, type, ...);`

## Unit-like structs
-> You can create unit-like structs, essentially an empty tuple
-> Used when you want to implement a trait on a type that doesn't hold any data
-> Behaves similarly to Unit / `()`, hence the name
-> `struct StructName;`

-> When borrowing a struct you do not move neither the struct, nor its fields. So the entire ownership remains at the current owner

-> Some derived traits currently shown: `#[derive(Trait)]`
	-> Display
	-> Debug
-> To use the Display formatting use `{}`
-> To use the Debug formatting use `{:?}`
-> To use prettier Debug formatting use `{:#?}`

-> Another way of printing debugging information is the macro `dbg!()`
	-> Keep in mind that `dbg!` takes ownership of the values you give it. `print!` and `println!` just borrow the value
	-> `dbg!` prints to `stderr`, not `stdout`
	-> You can pass reference to dbg when you dont want it to take ownership
	-> `dbg!` also returns ownership of the expression. So you can do something like `let width = dbg!(x * 2);` and it will print to stderr and also return the result to width

-> `derive` is an attribute. More can be found in the Rust Reference

# Methods
-> Similar to functions, also declared with `fn`
-> Methods are defined in the context of structs, enums or trait objects
-> The first parameter of a method is always `self`, representing the object it is being called on

-> To define the context of a struct, use `impl StructName {}`
-> Inside `{}` you can define the methods

# Associated functions
-> All functions defined inside the `impl` block are associated funcitons, including methods
-> Associated functions don't need to have the self parameter. Thus, making then *not* methods
-> Often used for constructors that return a new instance of that type. Take for example `String::from`

-> You can separate the `impl` blocks and a struct can have as many as you want to give it
-> Right now it doesn't make much sense to separate the methods in multiple `impl` blocks, but it will prove useful for generics