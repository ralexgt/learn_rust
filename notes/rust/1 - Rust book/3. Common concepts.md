[[learning]]  [[programming]]
-> variables, basic types, functions, comments, control flow

# Variables and mut
-> Rust variables are immutable by default
-> `cannot mutate immutable value of X` compiler error when trying to reassign an immutable

-> let vs. const
- consts are usually names with all capitalized snake case
- consts are always immutable and can not be used with the keyword mut
- the type must be annotated when you declare it
- you can only assign a constant expression to a const. So just an expression of which result you know at the compile time

-> shadowing: the first variable is "shadowed" by the second declaration
-> shadowing differs from mut because you have to use `let` to reassign a value, otherwise the compiler shouts. You can also change the type of the value, thus not needing to come up with multiple names for the same variable that you want to cast to a different type

# Data types
-> Rust is a strict, statically typed language

## Scalar types in Rust
- Integers
-> Numbers without fractional part
-> i8, i16, i32, i64, i128, isize, u...., 
-> isize, usie are architecture-dependent
-> Number literals that can have more than one type are allowed a type suffix, for example `58u8`
-> Mainly use isize, usize when indexing some sort of collection (when working with memory references)
- Floating-point numbers
-> f32, f64; default is f64
-> all floating point numbers are signed
- Booleans
-> bool, 1 byte
-> true | false
- Characters
-> char is the most primitive alphabetic type
-> 4 bytes in size and represents a unicode scalar value
-> character literals are in ' ', while string literals are in " "
### Compound types
Most primitive compound types in Rust are tuples and arrays
- Tuples
-> General way of grouping together a number of values with different types
-> Tuples can't change in size. Once declared they won't shrink or grow
-> Access a tuple element using `.` or by destructing the tuple with a pattern
**-> The empty tuple is called a unit. The value and the type are both written as `()`
Any expression that does not return something, returns `()`**
- Arrays
-> Collection of multiple values of the same type
-> Arrays have fixed length. Once allocated you can't grow or shrink an array
-> When declaring the type of an array you can also declare the length. \[i32; 5] (it will allocate space on the stack for 5 i32 values)
-> Similarly, you can specify an array that has one value repeated X times like this: `let arr = [3; 5]` this would be equal to `let x = [3, 3, 3, 3, 3];`
-> An array is a known, fixed size chunk of memory on the stack. So you can access its elements by 0-indexing in `[]`


***All the types so far allocate data on the stack***


# Functions
-> fn
-> Statements do something and return nothing
-> Expressions evaluate to a resultant value
-> Creating a variable with `let` is a statement
-> When you have an expression at the end of a scope block you do not put `;`

-> Return values are marked with `-> type` after the parantheses
-> You don't need to name the return value
-> In a function, the final expression is returned implicity
-> You can also return early from the function using `return`, but usually the last expression is used without `return`

# Comments
-> // in-line comment
-> You can also have `*code* // comment` but it is idiomatic to put the  `// comment` on the above line, annotating the code

# Control flow
-> Run code if a condition is true or while it is true
-> Most common are `if`s and loops
## if
-> Rust doesnt auto convert the expression result to boolean, so we need to be explicit with the condition
-> `if condition {} else if condition {} else {}`
-> If you have more than one `else if` you might want to refactor the code maybe with a `match`
-> `if` is an expression. So it returns a value. So it can be used in statements like `let`. The expressions need to evaluate to the same type so the compiler nows at compile time what type a variable is and doesnt need to take into account hypotaticales.

## Loops
-> `loop`, `while`, `for`
### loop
-> Executes a block of code forever or until you tell it to stop
-> `continue;` `break;`
-> You can use the loop to return the expression to a value. You can use `break expression;` to return the expression at the end of the loop

-> **loop labels** 
	-> `'loop_label` they start with a ' to denote they are labels
	-> You can use the in break or continue statements like this: `break 'label_name;`
	-> To set up a label for a loop use `'label_name: loop {}`
	-> If no label names used, `break` and `continue` will take effect for the innermost loop
### while
-> a loop with condition attached
-> condition is checked each itteration
-> Used to not have nasty indentation and unreadable code with `loop`, `if`, `break`
-> `while condition {}`

## for
-> loop through collections
-> .. = range syntax. a..b where a inclusive, b exclusive