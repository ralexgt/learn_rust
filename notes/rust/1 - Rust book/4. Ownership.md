[[learning]]  [[programming]]
-> how it avoid the need of a garbage collector and keep it memory safe

## Ownership rules
1. Each value has an owner
2. There can only be one owner at a time
3. When the owner goes out of scope, the value will be dropped

`drop`
-> Rust automatically calls `drop` when the variable goes out of scope
-> You can modify the `drop` function to do what you wish when it is called

-> A move is basically a shallow copy, but the first reference is invalidated
-> So lets say I have a variable `a` and I assign it to `b`. If `a` does not implement `clone` i.e. if cloning `a` would be expensive it only copies the reference stored on the stack to the data stored on th eheap
-> Rust doesnt allow two references to the same data, so when accessing and invalid reference, the compiler will complain because you are trying to borrow the value after it was `moved`

-> Rust will never automatically make a `deep copy` of your data. So any copying should be implied as being inexpensive
-> With costs taken into consideration, you can use `.clone()` to avoid moved values problem

-> Also changing data binded to a variable will lead to dropping unused heap memory
-> Let's say we assign `s` a string, then immediately reassign it with something else. The first string will be dropped and the memory freed.
-> Data without an owner is immediately freed

### `.clone()`
-> Method used to make a 'deep copy'
-> So it actually copies data on the heap
-> To be used careful because it can rapidly impact runtime performance depending on the size of data
-> Using this, the first reference doesnt go out of scope. Instead, there will be 2 different references, pointing at 2 different memory locations on the heap.

### Known, fixed size data
-> Generally, stored on the stack
-> So data such as integers dont need to use `.clone` because there is seemengly no difference between shallow and deep copy. And being on the stack, the data is quick to push and pop from it, making it a less expensive operation

### Copy trait
-> will learn about traits in chapter 10
-> Specifically the copy trait can be used on types stored on the stack
-> It tells Rust that the value can be trivially copied and so the variable doesn't go out of scope when assigned to something else
-> The data is not `moved` in this case

-> You can not implement the `Copy` trait if the type or any of its parts  has implemented the `Drop` trait


-> Passing a value to a function will `copy` or `move` just like assignment would
-> You can also move ownership with by returning from a function

# Refrences
-> We do not always need to move the data to the function. We can pass a reference
-> The action of referencing something in Rust is called borrowing.
-> When you are done with what you borrowed you give back to the owner and the data is not dropped

-> A references can be mutable
-> If you make a mutable reference, you can not make any other reference as long as the mutable one exists
-> You can have multiple immutable references
-> References must always be valid

# Slices
-> Let you reference a contiguous sequence of elements in a collcetion
-> A slice is a reference, so it doesn't have ownership over the data 
-> When you make a slice with `v\[a..b]` you can ommit `a` if you want to start at `0` and omit `b` if you want to end at the `len`

## String literals
-> `&str` is a string slice / reference
-> String literals are reference to the string literal in the binary output
-> `&str` is an  immutable references so string literals are immutable

-> Slices can be used in general with collections, not just strings
