[[learning]]  [[programming]]
-> A pointer is a general concept for a variable that contains an address in memory
-> This address refers to (or "points at") some other data
-> The most common pointer in Rust is a reference `&`. They are used to borrow the value they point to. They don't have any special capabilities other than referring to data and they have no overhead

-> Smart pointers are data structures that act like a pointer but have additional metadata and capabilities
-> While references only borrow data, usually smart pointers *own* the data they point to
-> Smart pointers are usually structs that implement `Deref` and `Drop`
-> There are some really common smart pointers in the standard library, but you can create your own and many packages create their own
	-> `Box<T>` for allocating values on the heap
	-> `Rc<T>` a reference counting type that enables multiple ownership
	-> `Ref<T>` and `RefMut<T>`, accessed  through `RefCell<T>`, a type that enforces borrowing rules at runtime instead of compile time

# `Box<T>` to Point to Data on the Heap
-> Using `Box<T>` type create a pointer on the stack to the value of `T` on the heap
-> No performance overhead expect storing the value on the heap, but also don't offer many extra capabilities
-> Used when:
	-> You have a type whose size can't be known at compile time and you want to use it in a context that requires an exact size
	-> You have a large amount of data and you want to transfer ownership but ensure that the data won't be copied
	-> When you want to own a value and only care that it's a type that implements a particular trait, rather than being of a specific type
-> `Box::new()`

-> Recursive types mean that the variable holds a value of the same type as the actual value
-> In Rust it creates an issue, because the compiles needs to know exactly how much space a type takes up. We use `Box` because it has an exact known size on the stack and we can enable the recursive types on the heap

# Treating smart pointers like regular references
-> Implementing `Deref` allows you to use `*` to dereference and so work on code that operates on references and use that code with smart pointers too
-> One difference between `Box` and a regular `&` is that the reference points to the value we define it on. `Box` will point to a copy of that data, especially is the original data is on the stack.
-> Creating your own smart pointer, at first being just a struct you will not be able to compile code that dereferences it `*`. Will need to implement `Deref` Trait
-> After we implement `Deref`, `*x` would be replaced with `*(x.deref())`
-> Similar to `Deref`, there is `DerefMut` trait to override `*` on mutable references`

# `Drop` trait
-> Trait used to define what happens when a value is about to go out of scope
-> `Drop` can be provided on any type and that code could be used to release resources like files or network connections
-> The trait is introduced here because it has to be implemented for smart pointers. For `Box`, for example, when the pointer on the stack is about to go out of scope, it has to also deallocate the space on the heap that the box points to
-> To implement the `Drop` trait you are required to implement the `drop` functions which takes a mutable reference to `self`

# Reference-Counted Smart Pointer
-> Unmutable references counter
-> `Rc<T>`
-> You could enable multiple ownership explicitly by using the Rust type `Rc<T>`, abbreviation for refrence counting
-> It keeps track of the number of references to a value to determine whether or not the value is still in use
-> If there are no references left, the value can be cleaned up
-> `Rc<T>` can be used only in single-threaded scenarios, for concurrency will use atomic types
-> `Rc::clone(&a)` used to clone the reference to a value. This doesn't create a deep copy, only creates a new reference and adds 1 to the reference counter, so there is no big performance problem here
-> `Rc::strong_count(&a))` returns how many references there are to a

# `RefCell<T>` interior mutability pattern
-> Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to the data - normally disallowed by the borrowing rules
-> The pattern uses `unsafe` code inside a data strcuture to bend Rust's usual rules that govern mutation and borrowing
-> `unsafe` code indicates to the compiler that we're checking the rules manually instead of relying on the compiler to check them for us
-> It shall be used only when we can ensure that the borrowing rules will be followed at runtime, even though it can't be sure at compile time
-> The `unsafe` code is wrapped in a safe API and the outer type is still immutable

-> `RefCell` type represents single ownership over the data it holds
-> With `RefCell<T>` the borrowing rules are enforced at runtime, instead of compile time, so the program will panic and exit if you break them
-> Only used in single-threaded scenarios
-> It would be useful if a variable could be mutable in one of its methods, but appear immutable for the rest of the code
-> For example, in a mock object for tests
-> On a `RefCell` value you can then use `borrow()` and `borrow_mut()` to get the actual value inside
-> When you borrow from `RefCell`, it has a counter that manages you many mutable and immutable references you have, those references implement `Deref` so you can use them as references, even tho they are Smart Pointers
-> Just like normal references, you can have as many `Ref` as you want OR one `RefMut` at a time. If we violate those rules, the program will panic at runtime, without any compile time error!!!

# `RefCell + Rc` for multiple owners of mutable data
-> `Rc<RefCell<T>>`
-> `Rc::new(RefCell::new(var_of_T))`
-> We create a reference counting that holds a `RefCell`. Such as, we can clone the reference counter to get multiple `RefMut` from the `RefCell`

# Reference Cycles can leak memory
-> If you have `RefCell<T>` values that contain `Rc<T>` or similar nested combinations of types with interior mutability and reference counting, you must ensure that you don't create cycles. Rust can't catch those.

-> Preventing cycles with `Weak<T>`
->  You can downgrade an `Rc` with `Rc::downgrade` and passing the reference to the `Rc<T>` to a weak reference
-> Weak references don't express ownership relationship and their count doesn't affect when an `Rc<T>` instance is cleaned up
-> Calling `Rc::downgrade` gives you a smart pointer of type `Weak<T>`
-> Instead of increasing the `strong_count` by 1, it increases the `weak_count` by 1
-> The difference between the 2 is that `weak_count` doesn't need to be 0 in order for the compiler to clean up the memory