[[learning]]  [[programming]]
-> Enumerations / enums
-> Define a type by enumerating its variants
-> Option enum => a value cand be something or nothing
-> `match` to pattern match on the type of an enum variable
-> `if let`

# Enums
-> Give you a way to say that a  value is one of some possible values
-> `enum EnumName {}`
-> `let x = EnumName::Type;`
-> You can use `impl` blocks to define methods just like with structs

# The Option enum in std lib
-> Option can hold either something (Some()) or nothing (None)

# Match
-> Pattern matching control flow
-> Patterns can be values, variable names, wildcards and other things
-> The compiler ALWAYS checks that all the cases are handles
-> `match expression {cases_to_handele}`
-> You can have a "catch all" arm in the match `_` or if you need the variable you can name it. In this case, you can handle how many cases you wish and have a catch all arm for the rest of the cases

# If let
-> When `let match` would be too verbose
-> `if let pattern = expression {code}` where pattern is the what would be the first pattern in the match and expression what would be in `match expression {}`
-> The code in the if block only runs if the expression matches the pattern
-> You can also add an `else` for the catch all pattern