[[learning]]  [[programming]]
-> Functions as values by passing them in arguments
-> Returning functions from other functions
-> Assigning functions to variables for later execution
-> Closures
-> Iterators

# Closures
-> Closures can capture values from the environment they are defined in for later use
-> A closure is started with `|| closure_body`
-> If the closure has parameters, they are writen between the pipes
-> Closures are typically short and relevant only within a narrow context
-> A difference between a closure and a function is that we do not usually need to annotate the parameters and return types. Rust can infer them in the narrow context that the closures are defined
-> Passing values to a closure is like to a function (passing a mutable reference, passing an imutable reference, giving ownership). The closure will decide which way to take the parameter based on what we do with it in the function body
-> To force a closure take ownership of a value use `move`
-> Taking ownership is usually used in threads, to move the value to the new thread. The parameter NEEDS to be moved to the new thread, because for example main could finish before the spawned thread and the borrowed value would disappear

-> Closures will automatically implement one, two or all three of the `fn` traits, depending on how the closure's body handles the borrowed or moved values:
	-> `FnOnce` applies to closures that can only be called once. All closures implement this trait
	-> `FnMut` applies to closures that don't move captured values out of their body but ight mutate the captured value. The closures can be called more than once
	-> `Fn` applies to closures that don't move captured values out of their body and don't mutate captured values, as well as closures that don't capture anything from their environment 

# Iterators
-> Perform some task on a sequence of items in turn
-> The iterator is responsible for the logic of iterating over each item and determening when the sequence is finished
-> Iterators are lazy. They have no effect until you call methods that consume the iterator to use it up
-> All iterators implement an `Iterator` trait and a `next` method
-> `iter` gives imutable references, `into_iter` gives owned values, `iter_mut` give mutable references
-> There are producers like `map` and consumers like `sum`
-> Many consumers take closures as arguments, like `filter`