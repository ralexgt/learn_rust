[[learning]]  [[programming]]
-> Included support for writing automated software tests
-> Tests are Rust functions that verify that the non-test code is functioning as expected
-> Test function bodies usuly perform three actions:
	-> Set up any needed data or state
	-> Run the code you want to test
	-> Assert that the results are what you expect

-> A test function is annotated with the `test` attribut, similar to how you annotate with the `derive` attribute
-> `#[test]` on the line before `fn`
-> Running `cargo test` results in a test runner binary that runs annotated test functions and reports on wether each function passes or fails

-> A test fails when something in the function panics

-> Tests are usually placed in a test module. This module is just as any other modules, meaning it respects the rules of visibility in [[7. Packages, crates, modules]]

-> You can use a bunch of `assert!` macros
-> `#[should_panic]` tests that a functionality panics in certain conditions

-> You can have a `Result<T, E>` as a tests output, intead of asserts
	-> This allows us to use the `?` operator in test functions


# Controlling how to run the tests
-> There are some command line options that go to `cargo test` and some that go to the resulting binary
-> To seprate the two types of arguments, you list those that go to `cargo test` then separate those with the `--` separator so you can list the arguments that go to the binary
-> `cargo test --help` will output the ones that go to cargo
-> `cargo test -- --hlep` will display the options that go to the binary

-> By default, all tests run in parallel. So you have to be careful not to have tests that depend one on another, no shared state and for example no writing on the disk because you can have unknown behavior
-> If you need to do one of these, you can make the tests run consecutively using the binary option `--test-threads=1`
-> binary option `--show-output` display the output even from tests that passed

-> You can filter tests by name, following the `cargo test` command with the substring of the names of the tests we want to run
-> The module in which the test is written is also part of the name. Meaning we can also separate tests in different modules and filter on that

-> In code, we can use `#[ignore]` to ignore specific tests. After which `cargo test -- --ignored` will run just the ignored tests and if you want to test all tests, regardless of ignored or not use `cargo test -- --include-ignored`


# Test organization (unit vs. integration)
-> Unit tests are smaller and more focused, testing one module in isolation at a time and they can test private interfaces
-> Integration tests are entirely external to your library and use your code in the same way any other code would, using public interface and potentially exercising multiple modules per test

## Unit tests
-> The convention is to unit test each part of your code, in the same file that code was written
-> At the end of the file you would create a module called tests and annotate it with `#[cfg(test)]`
-> The annotation tells Rust to compile and run the test code only when you run `cargo test`
-> In addition, each individual function in the test function, if we want it to be a test we annotate it with `#[test]`
-> We can also have non-test functions that help share behavior between different tests

-> Rust's privacy rules make it easy to test even private functions (functions that do not have `pub`)
-> Whether you should do that or not is a debate in the community (for me it makes sense to do it)

## Integration tests
-> In Rust, integration tests are entirely external to the library
-> They can only call functions that are part of your library's public API
-> Used to test whether many parts of your library work together correctly

-> To create integration tests, we create a `tests` directory in the root of the project (sibling with `src` and `Cargo.toml`), then cargo knows to look in the `tests` directory and each file will be treated as an individual crate
-> After which, in a file for example `integration_test.rs` you create the test functions, annotated with `#[test]` just like for unit tests, but you do not need to create the tests module
-> Each file in the tests directory is a different crate, so we need to bring our library into each test crate's scope

-> Cargo treats the code in `tests` directory as tests and only compiles the files here when we use `cargo test`

-> ***Note*** that if a test fails, it will not go to the next section (ex. if something fails in the unit tests it won't go to integration tests and if in integration tests it wont go to doc tests)

-> If we need to define some common behavior between the test files, we can not create it directly in `/tests` as a file. We will use the older naming convention, creating a directory `/tests/common` and create a `mod.rs` file there, with the commond behavior. Then in the other files that import the behavior use `mod common` and it will look in the `/tests/common`