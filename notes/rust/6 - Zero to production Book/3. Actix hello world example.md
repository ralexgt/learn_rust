# Analysing the Actix web hello world example
-> `HttpServer` handles things like: where should the application be listening, max number of concurrent connections, how many connections per unit of time, should we have TLS? and more.
	-> In short, it handles all transport level concerns
-> `App` hold application **logic**
	-> routing, middldewares, request handlers, etc.
	-> It takes incoming requests as input and returns a response
-> `route` defines endpoints
	-> It takes 2 parameters: `path` - a string, possibly templated and `route` an instance of the `Route` struct
-> `tokio` runtime
	-> We need main to be asynchronous because `HttpServer::run` is an asynchronous method. `main` is our entrypoint of the binary so it can not be asynchronous. So we have no one to poll `main` for when it has something to return. This being like this, we need to import an asynchronous runtime, which in this case is `tokio`
	-> If we use `cargo extand` we can see how the macro `#[tokio::main]` generates the code. Main is still actually synchronous and we have an `async` body in it